HTTP, The Definitive Guide @link(http://oreilly.com/catalog/9781565925090)
================================================================================

# Overview
The Hypertext Transfer Protocol is used to communicate over the Web.  HTTP, The
Definitive Guide is an informative guide on this protocol.  The authors are very
knowledgeable about HTTP and have covered almost the entire specification (along
with additional HTTP-related information) in an easy to read format.

# HTTP: The Web's Foundation
## Overview of HTTP
### Servers and Clients
Web browsers, servers, and other web apps all talk to each other via the
Hypertext Transfer Protocol.

HTTP uses reliable data-transmission protocols that guarantee that your data
will not be damaged or scrambled in transit.

{{ Servers }} store data, {{ clients }} send HTTP requests to servers.  Servers
return the requested data in HTTP responses.

Web servers host are said to host {{ resources }}, which can range from text
files, HTML files, images, movies, or even dynamic content.

HTTP tags each object being transported through the Web with a data format
called a {{ MIME type - Multipurpose Internet Mail Extensions }}.  It was
originally designed for emails, but it worked so well that HTTP adopted it.
When a client gets back an object with the MIME type, it will usually know
how to deal with it.

Example MIME types:
- text/html
- text/plain
- image/jpeg
- image/gif
- video/quicktime
- application/vnd.ms-powerpoint

### URIs and URLs
A {{ URL - uniform resource locator }} describes a resource's location.  It
tells precisely where a resource is located and how to access it.  Most URLs
have 3 main parts:
- the scheme (http://)
- server's Internet address (www.joes-hardware.com or 192.168.1.1)
- path to specific resource on server (/specials/saw-blade.gif)

A URL is a kind of {{ URI - uniform resource identifier }}, which act like
the postal addresses of the Internet.  Another kind of URI is the
{{ URN - uniform resource name }}.  A URN is a unique name for a particular
piece of content, independent of where the resource currently resides.
For example:
  urn:ietf:rfc:2141

URNs are still experimental and not yet widely adopted.

### HTTP Messages
An {{ HTTP transaction }} consists of a {{ request }} command and a 
{{ response }} result.  The communication happens with formatted blocks of data
called {{ HTTP messages }}.

There are different types of requests called {{ HTTP methods }}, which tells the
server what action to perform.  For example (incomplete):
- GET, send named resource form server to client
- PUT, store data from client into a named server resource
- DELETE, delete named resource from a server
- POST, send client data into a server gateway application
- HEAD, send just the HTTP headers from the response for the named resource

Every HTTP response comes back with a three-digit numeric {{ status code }} that
tells the client if the request succeeded or if other actions are required.
For example (incomplete):
- 200; OK. Document returned correctly
- 302; Redirect. Go someplace else to get the resource.
- 404; Not Found. Can't find this resource.

HTTP also sends a textual "reason phrase" with each numeric status code.  It's
included only for descriptive purposes.

HTTP messages are plain text, line-oriented messages.  Example request/response:

+---------------------------------+--------------------------+
| Request                         | Response                 |
+---------------------------------+--------------------------+
| GET /test/hi-there.txt HTTP/1.0 | HTTP/1.0 200 OK          |
| Accept: text/*                  | Content-Type: text/plain |
| Accept-Language: en,fr          | Content-length: 19       |
|                                 |                          |
|                                 | Hi!  I'm a message!      |
+---------------------------------+--------------------------+

Messages consist of 3 parts:
- {{ start line }}, first line of message indicating what to do 
  or what happened.
- {{ header fields }}, name/value pairs per line.
- {{ body }}, optionally following a blank line after the headers.
  Unlike the other parts, the body can contain arbitrary binary data.

Messages use {{ Transmission Control Protocol (TCP) }} connections to
move from place to place.  HTTP is an application layer protocol, it
leaves the details of networking to {{ TCP/IP }}.  TCP provides:
- error free data transportation
- in order delivery
- unsegmented data stream

### Behind The Scenes
HTTP is layered over TCP which is in turn layered of IP:
1. HTTP: application layer
2. TCP: transport layer
3. IP (Internet Protocol): network layer
4. Network-specific link interface: data link layer
5. Physical network hardware: physical layer

Before an HTTP client sends a message to the server it establishes a
TCP/IP connection using an IP address and port number.  Browsers usually
retrieve the IP address using a {{ hostname }}, example: www.netscape.com.
Hostnames are converted to IP addresses through the {{ Domain Name Service }}
or DNS.

The steps of a typical transaction are:
1. Browser extracts server's hostname from URL
2. Browser converts server's hostname into server's IP address
3. Browser extracts port number from URL (or defaults to 80)
4. Browser establishes TCP connection with web server
5. Browser sends an HTTP request to server
6. Server sends HTTP response back to browser
7. Connection is closed and browser displays the document

### Other Components
Some other architectural components of the web include:
- proxies: HTTP intermediaries that sit between clients/servers
- caches: HTTP storehouses that keep copies of pages close to clients
- gateways: special servers that connect to other applications
- tunnels: special proxies that blindly forward HTTP communications
- agents: semi-intelligence web clients that make automated requests

A {{ proxy }} sits between the client and server, receives all the client's HTTP
requests and relays it to the server (maybe modifying them).  They're often used
for security.  They can filter requests/responses; for example to detect viruses
or filter adult content.

{{ Caches }} are a special type of proxy server that keeps copies of popular
documents for performance reasons.  A client can download a document much more
quickly from a nearby cache than from a distant web server.

{{ Gateways }} are servers that act as intermediaries for other servers.  They
often convert HTTP traffic to another protocol.

{{ Tunnels }} are HTTP applications that blindly relay raw data between two
connections.  HTTP tunnels are often used to transport non-HTTP data over one
or more HTTP connections.  One popular example is to carry SSL encrypted traffic
through an HTTP connection.

{{ Agents }} are client programs that make HTTP requests on the user's behalf.
For example: web browsers are a kind of HTTP agent.

## URLs and Resources
### Syntax and URL components
Breaking down the URL http://www.joes-hardware.com/seasonal/index-fall.html:
- The first part (http) is the URL {{ scheme }} that tells the web client how
  to access the resource.  In this case, it says use the HTTP protocol.
- The second part (www.joes-hardware.com) is the {{ host }} and tells the
  client where the resource is hosted.
- The third part (/seasonal/index-fall.html) is the {{ resource path }} and
  tells the client what particular local resource on the server is requested.

URLs can point to any resource on the Internet, from an email account:
  mailto:president@whitehouse.gov
to files available through FTP:
  ftp://ftp.lots-o-books.com/pub/complete-price-list.xls

Most URLs adhere to this nine-part general format:
  <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>

+-----------+--------------------------------------------+-----------------+
| Component | Description                                | Default         |
+-----------+--------------------------------------------+-----------------+
| scheme    | which protocol to use                      | none            |
+-----------+--------------------------------------------+-----------------+
| user      | username some schemes require for auth     | anonymous       |
+-----------+--------------------------------------------+-----------------+
| password  | password for auth                          | <email address> |
+-----------+--------------------------------------------+-----------------+
| host      | hostname or dotted IP address of server    | none            |
+-----------+--------------------------------------------+-----------------+
| port      | port number server is listening on         | scheme-specific |
+-----------+--------------------------------------------+-----------------+
| path      | local name for resource on server          | none            |
+-----------+--------------------------------------------+-----------------+
| params    | name/value pairs                           | none            |
+-----------+--------------------------------------------+-----------------+
| query     | also used to pass params                   | none            |
+-----------+--------------------------------------------+-----------------+
| frag      | name for piece of the resource, not passed | none            |
|           | to the server (only used by client)        |                 |
+-----------+--------------------------------------------+-----------------+

Some servers require a username/password before you can access data.  If none
is given a default value of 'anonymous' is given for the username.  Browsers
will also send a default password (IE sends "IEUser" and Netscape Navigator
sends the password "mozilla").

URLs also have a {{ params }} component which is a list of name/value pairs.
They provide applications with any additional info that is needed to access
the resource.  For example, the FTP protocol allows you to define the transfer
mode to be text or binary:
  ftp://prep.ai.mit.edu/pub/gnu;type=d

The path component may be divided into {{ path segments }} separated by the "/"
character.  Each segment can have its own params component:
  http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true

Everything to the right of a '?' character is the {{ query }} component:
  http://www.joes-hardware.com/inventory-check.cgi?item=12731&color=red

The query string has no required format except that some characters are illegal.
By convention, most gateways expect the query string to be formatted as 
name/value pairs separated by the "&" character.

{{ Fragments }} allow clients to divide the resources into sections, for example
a chapter in a large HTML document.  Clients don't pass fragments to servers,
after your browser gets the entire resource from the server it will use the
fragment to display the part of the resource you're interested in:
  http://www.joes-hardware.com/tools.html#drills

### Shortcuts and Relative URLs
URLs come in two flavors: {{ absolute }} and {{ relative }}.  A relative URL
is interpreted relative to another URL, called its {{ base }}.  For example,
if your resource location is:
  http://www.joes-hardware.com/tools.html
And inside the document there was an anchor:
  <a href="./hammers.html">hammers</a>
It will be interpreted relative to the base "/tools.html" on joes-hardware.com:
  http://www.joes-hardware.com/hammers.html

Relative URLs may also infer the scheme:
  ://www.joes-hardware.com/hammers.html

### Encoding and Character Rules
URLs are permitted to contain only characters from a relatively small, 
universally safe alphabet in order to be portable and readable.  There are
also escape mechanisms so that URLs may be complete.

An encoding scheme was devised to represent characters in a URL that are not
safe.  It represents unsafe characters by an "escape" notion, consisting of a
percent sign (%) followed by two hexadecimal digits that represent the ASCII
code of the character.

Some characters have special meaning inside of a URL, are not defined by the
US-ASCII printable set, or are discouraged due to confusing some Internet
gateways and protocols:
- % escape token for encoded characters
- / delimiting splitting up path segments in path component
- ' reserved in the path component 
- " reserved in the path component
- # reserved for fragment delimiter
- ? reserved as query string delimiter
- ; reserved as params delimiter
- : reserved to delimit scheme, user/password, and host/port
- $,+ reserved characters
- @&= special meaning in context of some schemes
- {}|\^~[]‘  unsafe handling by various agents
- <>" should be encoding because they often have special meaning
- 0x00 to 0x1F, 0x7F restricted non-printable characters
- > 0x7F don't fall within 7-bit range of US ASCII set

Once all unsafe characters have been encoded, the URL is in a
{{ canonical form }} that can be shared.

### Common Schemes
Some popular schemes:
- http, conforms to general URL format
- https, twin to http scheme but uses SSL to provide encryption.
  Its default port is 443.
- mailto, refers to email addresses.  It's got a different format because
  it behaves differently (it does not refer to objects that can be accessed
  directly).  Documented in internet RFC822.
- ftp, File Transfer Protocol which follows the general format:
  ftp://<user>:<password>@<host>:<port>/<path>;<params>
- rtsp, rtspu are identifiers for audio/video media resources via the
  Real Time Streaming Protocol.
- file, denotes files directly accessible on given host machine by local disk
- telnet, access interactive services with the general format:
  telnet://<user>:<password>@<host>:<port>/

### Future and URNs
The {{ Internet Engineering Task Force (IETF) }} have been working on a new
standard, {{ uniform resource names (URNs) }}.  Whereas URLs represent a
location, URNs represent a name.  So even if a given resource moves, if you
have its name you should still be able to find it (similar to domain names vs
IP addresses).

URNs have been around for a while but have not been heavily adopted yet.  URLs
are currently the standard and will be for a while.

## HTTP Messages
### How Messages Flow
Messages are blocks of data send between HTTP applications.  Their direction is
described to be {{ inbound }}, {{ outbound }}, {{ upstream }}, or 
{{ downstream }}.

{{ Transactional }} direction are said to be inbound and outbound.  Messages
travel inbound to the origin server and when their work is done, they travel
outbound back to the user agent.

All messages flow downstream, regardless of whether they are requests or
responses.  The sender of the message is upstream of the receiver.

All HTTP messages are either {{ request }} or {{ response }} messages.  Requests
carry an action to a web server.  Response carries results back to a client.

The format of a request message:
  <method> <request-URL> <version>
  <headers>

  <entity-body>

And the format of a response message:
  <version> <status> <reason-phrase>
  <headers>

  <entity-body>

### Start Line
All messages begin with a start line which says what to do or what happened.
The start line for a request is the <method> <request-URL> and <version>.
Response start lines contain the <version> <status> and <reason-phrase>.

Version number appear in both request/response message start lines.  They
are in the format HTTP/x.y where x is the major version and y is the minor
version.  They're provided to help applications speak HTTP to each other.

### Headers
HTTP header fields add additional information to request/response messages,
they're name/value pairs.  For example:
  Content-length: 19

The spec defines several header fields, applications are also free to invent
their own headers.  They're classified into:
- General, can appear in both request/response
- Request, provides additional info about the request
- Response, provides additional info about the response
- Entity, describes body size, contents, or the resource itself
- Extension, new headers not defined by spec

The syntax is simple: a name, followed by a colon, followed by optional
whitespace, followed by the field value, followed by CRLF (Carriage Return
Line Feed).

Long header lines can be made readable by breaking them into multiple lines,
preceding each extra line with at least one space or tab character:
  HTTP/1.0 200 OK
  Content-Type: image/gif
  Server: Test Server
    Version 1.0
  Content-Length: 8572

For a complete list of headers defined in the spec, see the HTTP/1.1 
specification or Appendix C of this book.  Here's a general overview:
* General Headers
 - Connection: allows clients/server to specify options about connection
 - Date: timestamp for message
 - MIME-Version: MIME version sender is using
 - Trailer: set of headers in trailer of message encoded
 - Transfer-Encoding: what encoding was performed on message for transport
 - Upgrade: new version or protocol that sender would like to upgrade to
 - Via: shows what intermediaries message has gone through
* General Caching Headers
 - Cache-Control: pass cache directions with message
 - Pragma: another way to pass directions not specific to caching
* Request Headers
 - Client-IP: IP address of client
 - From: email address of client's user
 - Host: hostname and port being sent to
 - Referrer: URL of document that contains current request URI
 - UA-Color: capabilities of client machine's display
 - UA-CPU: type/manufacturer of client's CPU
 - UA-Disp: info about client's display capabilities
 - UA-OS: name/version of client's OS
 - UA-Pixels: pixel information about client's display
 - User-Agent: tells server name of application making request
* Accept Request Headers
 - Accept: what media types are okay to send
 - Accept-Charset: what charsets are okay
 - Accept-Encoding: what encodings are okay
 - Accept-Language: what languages are okay
 - TE: what extension transfer codings are okay
* Conditional Request Headers
 - Expect: list of server behaviors that client requires
 - If-Match: only get if entity tag matches
 - If-Modified-Since: only get if resource has been modified since
 - If-None-Match: get if entity tags supplied do not match
 - If-Range: get conditional range of document
 - If-Unmodified-Since: get if not modified since date
 - Range: request a specific range of resource
* Security Request Headers
 - Authorization: client supplied data to authenticate itself
 - Cookie: used to pass a token to server
 - Cookie2: note version of cookies a requestor supports
* Proxy Request Headers
 - Max-Forwards: max # of times a request should be forwarded
 - Proxy-Authorization: auth data for proxy
 - Proxy-Connection: options for proxy connection
* Response Headers
 - Age: how old response is
 - Public: list of request methods server supports
 - Retry-After: timestamp to try again if resource is unavailable
 - Server: name/version of server's application software
 - Title: for HTML documents, title of document
 - Warning: more detailed warning message than reason phrase
* Negotiation Response Headers
 - Accept-Ranges: type of ranges server will accept
 - Vary: list of headers server looks at
* Security Response Headers
 - Proxy-Authenticate: list of challenges for client from proxy
 - Set-Cookie: sets cookie on client side
 - Set-Cookie2: similar to Set-Cookie
 - WWW-Authenticate: list of challenges for the client from server
* Entity Headers
 - Allow: lists of request methods allowed on this resource
 - Location: tells client where entity is really located (redirect)
* Content Headers
 - Content-Base: base URL for resolving relative URLs within body
 - Content-Encoding: encoding performed on body
 - Content-Language: natural language best used
 - Content-Length: length or size of body
 - Content-Location: where resource is actually located
 - Content-MD5: MD5 checksum of body
 - Content-Range: range of bytes entity represents of entire resource
 - Content-Type: type of object that this body is
* Entity Caching Headers
 - ETag: entity tag associated with this resource
 - Expires: timestamp for when this resource will no longer be valid
 - Last-Modified: timestamp when this entity changed

### Entity Body
Entity bodies are what HTTP was designed to transport, they can carry many kinds
of digital data: images, video, plain text, HTML, software apps, etc...

### HTTP Methods
Methods help tell the server what to do in an HTTP request:
+---------+---------------------------------------------------+----------------+
| Method  | Description                                       | Body Required? |
+---------+---------------------------------------------------+----------------+
| GET     | Gets a document from the server                   | No             |
+---------+---------------------------------------------------+----------------+
| HEAD    | Gets just the headers for a document              | No             |
+---------+---------------------------------------------------+----------------+
| POST    | Send data to server for processing                | Yes            |
+---------+---------------------------------------------------+----------------+
| PUT     | Store the body of the request on the server       | Yes            |
+---------+---------------------------------------------------+----------------+
| TRACE   | Trace the message through proxy servers to server | No             |
+---------+---------------------------------------------------+----------------+
| OPTIONS | Determine what methods can operate on a server    | No             |
+---------+---------------------------------------------------+----------------+
| DELETE  | Removes a document from the server                | No             |
+---------+---------------------------------------------------+----------------+

Not all servers implement all seven methods and HTTP was designed to be
extensible so servers may implement their own request methods called
{{ extension methods }}.

To be compliant with HTTP v1.1, a server only needs to implement the GET and
HEAD methods for its resources.

HTTP defines a set of {{ safe }} methods (ie. GET or HEAD) meaning no action
should occur as a result of an HTTP request that uses GET or HEAD.  They're
meant to distinguish unsafe methods from end-users, ie. as a result of a request
your credit card may be charged.

HTTP was designed to be extensible and some additional methods are in common use
that are not declared in the spec, for example the WebDAV extension that
supports publishing content to servers:
- LOCK allows users to lock a resource
- MKCOL allows user to create a resource
- COPY facilitates copying resources
- MOVE moves a resource on a server

It's best to be tolerant of extension methods, since HTTP applications could run
into extension methods that it does not understand.  Proxies should forward them
and end servers should response with a 501 Not Implemented status code.  "Be
conservative in what you send, be liberal in what you accept."

### Status Codes
Status codes tell the client what happened in HTTP responses:
+---------------+---------------+---------------+
| Overall Range | Defined Range | Category      |
+---------------+---------------+---------------+
| 100-199       | 100-101       | Informational |
+---------------+---------------+---------------+
| 200-299       | 200-206       | Successful    |
+---------------+---------------+---------------+
| 300-399       | 300-305       | Redirection   |
+---------------+---------------+---------------+
| 400-499       | 400-415       | Client error  |
+---------------+---------------+---------------+
| 500-599       | 500-505       | Server error  |
+---------------+---------------+---------------+

Current versions of HTTP define only a few codes for each category.  The
specification will add more status codes in the future, but developers
may decide to extend the current protocol with their own status codes.  In
that case, you should treat it as a general member of the class whose range
it falls into.

{{ Reason phrases }} also come along with status codes.  Whereas status
codes are for machines, reason phrases are a textual explanation of the
status that's meant for humans.  The spec does not provide any hard rules
for what reason phrases should look like.

100-199 are informational status codes:
+------+---------------------+-------------------------------------------------+
| Code | Reason              | Meaning                                         |
+------+---------------------+-------------------------------------------------+
| 100  | Continue            | Initial part of request received, client should |
|      |                     | continue sending requests                       |
+------+---------------------+-------------------------------------------------+
| 101  | Switching Protocols | Server is changing protocols to one             |
|      |                     | in "Upgrade" header                             |
+------+---------------------+-------------------------------------------------+

For clients to use the 100 status code, it must send a request with an Expect
header with the value 100-continue.

200-299 are successful status codes:
+------+-----------------+----------------------------------------------------+
| Code | Reason          | Meaning                                            |
+------+-----------------+----------------------------------------------------+
| 200  | OK              | Request is OK, body contains requested resource    |
+------+-----------------+----------------------------------------------------+
| 201  | Created         | For unsafe requests, ie. PUT has created resource  |
|      |                 | with Location header containing specific reference |
+------+-----------------+----------------------------------------------------+
| 202  | Accepted        | Request accepted, but no action performed yet      |
+------+-----------------+----------------------------------------------------+
| 203  | Non-Auth        | Headers did not come from origin server            |
|      | Information     |                                                    |
+------+-----------------+----------------------------------------------------+
| 204  | No Content      | Response has start line and status, but no body.   |
|      |                 | Eg. update browsers without redirecting/refreshing |
+------+-----------------+----------------------------------------------------+
| 205  | Reset Content   | Eg. clear any HTML form elements on current page   |
+------+-----------------+----------------------------------------------------+
| 206  | Partial Content | Partial range successful, expecting more.          |
+------+-----------------+----------------------------------------------------+

300-399 are redirection status codes.  They tie heavily with the Location header
which should tell clients where to go to next:
+------+--------------------+--------------------------------------------------+
| Code | Reason             | Meaning                                          |
+------+--------------------+--------------------------------------------------+
| 300  | Multiple Choices   | Multiple redirect choices, preferred in          |
|      |                    | Location header                                  |
+------+--------------------+--------------------------------------------------+
| 301  | Moved Permanently  | Resource moved, use new URL                      |
+------+--------------------+--------------------------------------------------+
| 302  | Found              | Like 301, but is temporarily moved and client    |
|      |                    | should continue using the old URL                |
+------+--------------------+--------------------------------------------------+
| 303  | See Other          | Redirect response for POST for created resource  |
+------+--------------------+--------------------------------------------------+
| 304  | Not Modified       | If client sends conditional headers, such as the |
|      |                    | If-Modified-Since, server responds without body  |
+------+--------------------+--------------------------------------------------+
| 305  | Use Proxy          | Resource must be accessed through proxy          |
+------+--------------------+--------------------------------------------------+
| 307  | Temporary Redirect | Like 302, used for backwards compatibility       |
+------+--------------------+--------------------------------------------------+

400-499 are client error status codes:
+------+--------------------+-------------------------------------------------+
| Code | Reason             | Meaning                                         |
+------+--------------------+-------------------------------------------------+
| 400  | Bad Request        | Client has send malformed request               |
+------+--------------------+-------------------------------------------------+
| 401  | Unauthorized       | Client requires authorization                   |
+------+--------------------+-------------------------------------------------+
| 402  | Payment Required   | Not used                                        |
+------+--------------------+-------------------------------------------------+
| 403  | Forbidden          | Request refused by server                       |
+------+--------------------+-------------------------------------------------+
| 404  | Not Found          | Server cannot find requested URL                |
+------+--------------------+-------------------------------------------------+
| 405  | Method Not         | Request made with unsupported method. Should    |
|      | Allowed            | include Allow header with supported methods     |
+------+--------------------+-------------------------------------------------+
| 406  | Not Acceptable     | Client's "Accept" header has no available       |
|      |                    | option for server                               |
+------+--------------------+-------------------------------------------------+
| 407  | Proxy Auth Req.    | Proxy requires authentication                   |
+------+--------------------+-------------------------------------------------+
| 408  | Request Timeout    | Client taking too long to send request          |
+------+--------------------+-------------------------------------------------+
| 409  | Conflict           | Server is afraid conflict of resource may arise |
+------+--------------------+-------------------------------------------------+
| 410  | Gone               | Similar to 404 but permanent                    |
+------+--------------------+-------------------------------------------------+
| 411  | Length Required    | Client needs to send Content-Length header      |
+------+--------------------+-------------------------------------------------+
| 412  | Precondition       | Client included an Expect header and conditions |
|      | Failed             | cannot be met by server                         |
+------+--------------------+-------------------------------------------------+
| 413  | Request Body       | Client's entity body larger than what server    |
|      | Too Large          | can or wants to process                         |
+------+--------------------+-------------------------------------------------+
| 414  | Request URI        | Same as 413, but with request URI               |
|      | Too Long           |                                                 |
+------+--------------------+-------------------------------------------------+
| 415  | Unsupported Media  | Client sends an entity of content type that the |
|      | Type               | server does not support                         |
+------+--------------------+-------------------------------------------------+
| 416  | Requested Range    | Requested range is invalid                      |
|      | Not Satisfiable    |                                                 |
+------+--------------------+-------------------------------------------------+
| 417  | Expectation Failed | Request's Expect header cannot be satisfied     |
+------+--------------------+-------------------------------------------------+

500-599 are server error status codes.  This occurs if the client sends a valid
request, but the server itself has an error:
+------+---------------------+-------------------------------------------------+
| Code | Reason              | Meaning                                         |
+------+---------------------+-------------------------------------------------+
| 500  | Internal Server     | Server encounters error                         |
|      | Error               |                                                 |
+------+---------------------+-------------------------------------------------+
| 501  | Not Implemented     | Client makes request beyond server's capability |
+------+---------------------+-------------------------------------------------+
| 502  | Bad Gateway         | Server acting as proxy/gateway encounters error |
+------+---------------------+-------------------------------------------------+
| 503  | Service Unavailable | Server temporarily cannot service request       |
+------+---------------------+-------------------------------------------------+
| 504  | Gateway Timeout     | Similar to 408, except response is from gateway |
+------+---------------------+-------------------------------------------------+
| 505  | HTTP Version        | Server does not support client's HTTP version   |
|      | Not Supported       |                                                 |
+------+---------------------+-------------------------------------------------+

## Connection Management

# HTTP Architecture
## Web Servers
## Proxies
## Caching
## Integration Points: Gateways, Tunnels, and Relays
## Web Robots
## HTTP-NG

# Identification, Authorization, Security
## Client Identification and Cookies
## Basic Authentication
## Digest Authentication
## Secure HTTP

# Entities, Encodings, and Internationalization
## Entities and Encodings
## Internationalization
## Content Negotiation and Transcoding

# Content Publishing and Distribution
## Web Hosting
## Publishing Systems
## Redirection and Load Balancing
## Logging and Usage Tracking

