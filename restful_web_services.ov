RESTful Web Services
================================================================================

# Overview
{{ Representational State Transfer }} or REST, described in Roy Fielding's
dissertation, is an architecture for designing web services that emphasizes
HTTP's strength and simplicity.  There is no definitive specification and an
application is never said to be "REST-compliant", instead we say an application
is "RESTful" - just as you can write functional code in a language designed for
object oriented programming.

This book introduces the {{ Resource-Oriented Architecture }}, which is a set of
best practices for developing RESTful web services.  Along the way, it also
describes what REST means to clients/services and how to implement it.

# Programmable Web
Some qualities of RESTful web services are:
* they use the HTTP method to distinguish between actions
* they use the URI to distinguish between resources and components (ie.
  scoping information for a list of resources)

The web is full of data, but instead of downloading all the data at once
you get a web browser and interact with {{ web services }} like search engines,
movie databases, book databases, etc... to retrieve data, store/search data,
and perform other actions.

The programmable web works the same way, except other clients exist besides
browsers (or you can develop your own client) and instead of HTML pages
you usually get an easy-to-parse XML or JSON response.

Websites such as google.com and amazon.com are also web services.  URIs are 
used to fetch data and the responses are in HTML, made for human consumption 
instead of for a computer to parse.

More commonly known as web services are APIs which give access to data such
as Amazon's S3 or Delicious' API.  Web services are also commonly used 
internally in distributed architectures.

This book splits web services into 3 categories:
* RESTful resource-oriented
* RPC-style
* REST-RPC hybrid

RESTful resource-oriented architectures use HTTP verbs to distinguish actions
and will have URIs designed around {{ resources }}.  A URI represents a thing
and the HTTP verb that the client sends will tell the server what to do with
that particular thing.

RPC style architectures tend to convey action information in other ways than the
standard HTTP verbs.  Ie. they might use the query portion of the URI:
  GET http://api.example.com/?q=DeleteUser&id=1

They may also define their own {{ envelope }} standard instead of using HTTP.
For example, all requests may be POSTs with XML entity bodies.  The server
determines what to do by parsing the entity body.

# Writing Web Service Clients
A web service client is just a specialized HTTP client that's programmed for
a specific web service.  It's built to make a request and parse the response.  
You can use your language's standard library to do this.

Wrappers make developing clients easier because an API is tailored to one
particular service.  Instead of making raw HTTP GET/PUT requests to Amazon's
S3 library, it's easier to use the amazon-aws library.

The SOAP RPC community has WSDL, for RESTful web services there is the less
widely known {{ WADL - Web Application Description Language }}.  The developer
can write a single WADL file which describes the resources and a client API
will be generated for it.

{{ ActiveResource }} is another library that's custom made as the client
library opposite to Rail's REST support.

Ruby has {{ open-uri }} which is easy to use but only supports GET requests
and does not allow you to set headers.  The author has created his own library,
{{ rest-open-uri }} which can be used to develop REST clients.  You can also
dive down into {{ net/http }} which exposes the raw HTTP requests/responses.  On
the command line, {{ curl }} is a useful utility.

To process the response, you'll need a good XML or JSON library depending on
which entity encoding is used for the HTTP responses.  There are two types of
XML parses: the DOM/tree based strategy and the SAX/pull based strategy.  The
DOM based libraries will parse the entire document at once while the SAX based
one will allow the programmer to define hooks to events and use the XML document
as a stream of data.

Ruby has {{ REXML }} which is the default XML parser that supports both DOM and
SAX interfaces.  The author does not recommend it because it only works with
well formed documents.  To handle bad markup, the author recommends using 
{{ hpricot }} available http://code.whytheluckystiff.net/hpricot/,

Here's a sample Delicious client written in Ruby:
  #!/usr/bin/ruby -w 
  require 'rubygems' 
  require 'open-uri' 
  require 'rexml/document'

  def print_my_recent_bookmarks(username, password)
    response = open('https://api.del.icio.us/v1/posts/recent', 
                    :http_basic_authentication => [username, password])
    xml = response.read  
    document = REXML::Document.new(xml)
    REXML::XPath.each(document, "/posts/post") do |e|
      # Print the bookmark's description and URI
      puts "#{e.attributes['description']}: #{e.attributes['href']}" 
    end
  end

  username, password = ARGV 
  unless username and password
    puts "Usage: #{$0} [username] [password]"
    exit 
  end
  print_my_recent_bookmarks(username, password)

# What Makes RESTful Services Different
Amazon's Simple Storage Service (S3) is an example of a popular RESTful service.
S3 has an object-oriented design.  There are two concepts: buckets and objects.
An object is a file and associated metadata (like filename or permissions) and
are stored in named buckets.

S3 has a simple RESTful API.  The developer has access to two types of resources
(the buckets and objects mentioned above).  To perform actions on those
resources, developers just need to issue plain HTTP requests.  The HTTP method
used will distinguish between which action:

+-----------------+-----------------+--------------+---------------+--------+
|                 | GET             | HEAD         | PUT           | DELETE |
+-----------------+-----------------+--------------+---------------+--------+
| /               | List buckets    | -            | -             | -      |
+-----------------+-----------------+--------------+---------------+--------+
| /{bucket}       | List bucket's   | -            | Create bucket | Delete |
|                 | objects         |              |               | bucket |
+-----------------+-----------------+--------------+---------------+--------+
| /{bucket}/{obj} | Download object | Get metadata | Set value     | Delete |
|                 |                 |              | and metadata  | object |
+-----------------+-----------------+--------------+---------------+--------+

Some examples:
* GET / => get the list of available buckets
* PUT /nantucket => creates a new bucket named "nantucket"
* PUT /nantucket/file1 => uploads a new file named "file1"

RESTful services have obvious APIs because it follows the HTTP specs.  URIs map
to resources (instead of actions) and the HTTP actions are used to distinguish
between verbs (ie. create vs delete).

# Resource-Oriented Architecture
The properties of a Resource-Oriented Architecture are:
* addressability - scoping information should be kept in the URI
* statelessness - keeping application state on the client and resource state
  on the server
* connectedness - "Hypermedia as the engine of application state", linking
  resources together
* uniform interface - using the HTTP methods as they are defined in the spec

The components that make up ROA are resources, their names/URIs, their
representations, and the links between them.

A {{ resource }} is anything that's important enough to be referenced on your
web service.  It has at least one URI which is the name and address of the
resource.  URIs should be descriptive, have structure (vary in predictable ways)
and should contain scoping information (aka {{ addressability }}).

Some example URIs are:
* http://www.example.com/software/releases/1.0.3.tar.gz
* http://www.example.com/software/releases/latest.tar.gz
* http://www.example.com/search/Jellyfish
* http://www.example.com/sales/2004/Q4
* http://www.example.com/bugs/by-state/open

{{ Statelessness }} means every HTTP request happens in complete isolation.  
Possible states of a resource should be given their own URI.  For example, 
Google handles the state of pagination in its URI using the query string 
(?page=1).  ROA requires that state be stored on the client side and sent to the
server on each request.

Of course that's only the case for {{ application state }}.  Application state
deals with the session, like what page a client is currently on.  State that
lives in the database is perfectly fine and is called {{ resource state }}.
This is state like a user's email address, or the current state of a blog post.

While a resource has useful information, its {{ representation }} is what the
client gets.  The representation may be in different parse-able formats including
HTML, XML, or JSON.  It may be in different encodings or different languages.
A client can tell the service what sort of representation it expects using
{{ content negotiation }} (via the Accepts header), or the service designer may
place the content information within the URI.  For example:
  http://www.example.com/en/search/Jellyfish.json

In most RESTful services, representations of resources are hypermedia documents
which contain links to other documents.  The server guides the client's path by
serving "hypermedia": links and forms inside hypertext representation.  This
is the {{ connectedness }} of ROA.  An example of this is a search engine.  You
start from http://google.com, enter data into a form, and get an HTML document
back full of links to explore the web.

{{ Uniform interface }} means using the HTTP methods as they were defined in the
HTTP specification.  This makes RESTful APIs, like S3's, more obvious because 
they all follow the same interface:
* GET to retrieve a representation of a resource
* PUT to a new URI to create a new resource
* POST to an existing URI to create a new resource
* PUT to an existing URI to modify an existing resource
* DELETE to delete an existing resource
* HEAD to retrieve only the metadata of a resource
* OPTIONS to check which HTTP methods are supported on a URI

The difference between {{ POST vs PUT }} is subtle.  GET, HEAD, PUT, and DELETE
actions are supposed to be {{ idempotent }}.  This means there's no difference
between making one request vs making many.  They were originally defined as
idempotent methods for faulty networks.  GET and HEAD are {{ safe }} requests
meaning they should not change any state on the server (actually, it's okay to
have side-effects like hit counters - but it shouldn't change state where it
matters).

POST is not idempotent.  If your request changes state and is not idempotent,
that's an indication that it should be using POST.  Another subtle difference
between PUT and POST can be seen from the HTTP specification:
* PUT - used to upload data from the client to the server at a named resource
* POST - various reasons to use including uploading data from a form to be
  processed by some gateway application

Rails applications tend to map POST/GET/PUT/DELETE to Create/Read/Update/Delete,
which mostly works.  Amazon uses the PUT method to create buckets/objects
because the path for both actions uses an already named resource.  Naming the
bucket/object occurs on the client-side (and is idempotent).  Rails applications
tend to use incremental IDs in their paths which are determined on the server
side, so requests are no longer idempotent.  Hence POST is commonly used.

HTTP was designed with idempotent/safe requests in mind because of unreliable
network connections.  Some clients are designed to with this assumption.  Web
accelerator was a product which pre-fetched links (using GET) to speed up
a user's experience on the web.  It was a disaster because developers used
links and GET requests to perform non-safe actions.  So the product ended up
changing server state, such as deleted resources in the database.

# Read-Only Resource-Oriented Services

The author shows us how he would design a read-only ROA web service.  His
particular service is for retrieving maps of locations around the universe
(including other planets!).

The steps he goes through are:
1. Figure out the data set
2. Split the data set into resources, and for each resource:
   1. Name the resource with a URI
   2. Expose a subset of the uniform interface
   3. Design the representation(s) accepted from the client
   4. Design the representation(s) served to the client
   5. Integrate resource into existing resources using hypermedia links/forms
   6. Consider typical course of events: what's supposed to happen?
   7. Consider error conditions: what might go wrong?

A resource is anything interesting enough to be the target of a hypermedia link.
Some examples are:
* Predefined one-off resources (like homepage or S3's home bucket)
* A resource for every object exposed through the service
* Resources representing the results of algorithms applied to the data set,
  such as a collection of objects from a search result or pagination

Representing and naming resources is similar to OOP.  Whereas procedural code is
split into procedures, OOP code is split into objects.  RPC-style services tend
to name functions like doSearch or subscribeFeed.  RESTful services will have
URIs named after nouns: /searches/jellyfish or /subscriptions/1337;24

The 3 basic rules for URI design:
1. Use path variables to encode hierarchy: /parent/child
2. Put punctuation in path variables to avoid implying hierarchy: 
   /parent/child1;child2 or /parent/child1,child2
3. Use query variables to provide input to algorithms:
   /search?query=jellyfish&start=20

You can represent your resources with a wide variety of formats ranging from XML
to JSON.  The author settles on using plain old XHTML.  Linked anchors are
also provided in documents for connectedness:
  <!-- doctype & head -->
  <body>
    <ul class="planets">
      <li><a href="/Earth">Earth</a></li>
      <li><a href="/Venus">Venus</a></li>
    </ul>
  </body>

Using request headers to distinguish between resource representations aren't
recommended.  Instead, clients can just tweak the URI to get a different 
representation.  Conditional GETs are recommended.

When an error occurs, your service should return something in the 3xx-5xx range.
Redirects are useful to provide an alternate location.  4xx should tell the
clients their error.  5xx for server errors that clients cannot fix themselves.

# Read/Write Resource-Oriented Services
# Service Implementation
# REST/ROA Best Practices
# Building Blocks of Services
# Resource-Oriented Architecture vs Big Web Services
# AJAX Applications as REST Clients
# Frameworks for RESTful Services
