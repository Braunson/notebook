HTML5 Up and Running @link(http://oreilly.com/catalog/9780596806033)
================================================================================

# Overview
HTML5 Up and Running by Mark Pilgrim is an informative guide to select features
from the HTML5 Specification. It's available at @link(http://diveintohtml5.org/)

# History
Every element, attribute, feature of HTML was created by someone who decided how
it should work and wrote it all down.  For example the <img> element:
1. Before there was a W3C, Marc Andreesen emailed his proposal for
   an <img> element with a "src" attribute to a mailing list.
2. People debated on it, came up with alternatives, and various implementations
   of it were done for different browsers.
3. Marc ended up implementing his original proposal in Mosaic.
4. And now we have an <img> element that became an HTML standard.

It's really as simple as this: we have an <img> element because Marc Andreesen
shipped on in his browser, and shipping code wins.

HTML has been constantly evolving.  It's always been developed between browser
makers, authors, standards "wonks", and other people who just wanted to get
involved.

In 1997, the W3C published the HTML 4.0 specification.  They then published the
XML 1.0 specification and decided to reformulate HTML into XML instead of 
trying to extend HTML.  That gave birth to XHTML 1.0 and XHTML 1.1.

XHTML has "draconian error handling".  If served with the correct MIME type,
{{ application/xhtml+xml }} browsers would complete break pages when there were
any minor errors.  So most people ended up using the {{ text/html }} MIME type,
which was a loophole.  It allowed authors to use an XHTML syntax but keep
serving it in a forgiving environment.

In 2004, the W3C branched off the What Working Group.  What WG wanted to work on
an evolution of the existing HTML 4 standard to include features for modern
web aplication developers:
* backward compatibility based on existing tech: HTML, CSS, DOM, and JavaScript
* well defined error handling (as opposed to the draconian error handling or 
  inconsistent error handling implementations between browsers)
* users should not be exposed to author errors
* practical useful features
* embrace scripting
* avoidance of device specific profiling
* web forms

WHAT Working Group = {{ Web Hypertext Applications Technology Working Group }}
They called their specification {{ Web Applications 1.0 }}

For years the W3C and What WG ignored each other, working on XHTML 2.0 and
Web Applications 1.0 respectively.  By 2006, Web Applications 1.0 was 
picking up more momentum while XHTML 2 remained mostly unimplemented by
browsers.  In October 2006, Tim Berners Lee announched that the What WG
and W3C would begin working together.  

Web Applications 1.0 was renamed to {{ HTML5 }}.  In October 2009, The W3C shut
down the XHTML2 Working Group.

"The ones that win are the ones that ship." - Mark Pilgrim

# Feature Detection
You can start using HTML5 now, it's a collection of individual features.
You can do this using feature detection.  If the current browser has a
certain feature - use it, otherwise fallback.

Detection techniques fall in four categories:
1. Check for property on global object (ie. window or navigator)
2. Create an element, then check if that element has a certain property
3. Create an element, check if a method exists, call that method, and check
   the return value
4. Create an element, set a property and check if the value is retained

Modenizr @link(http://www.modernizr.com/) is an HTML5 detection library.

# Updated and New Elements
## Doctype, Html, and Head
The new {{ doctype }} for HTML5 is: <!DOCTYPE html>

The root element just needs a {{ lang }} attribute set: <html lang="en">

Inside the {{ head }} element, you'll need to specify the content type and
character encoding of your document.  You may also specify any stylesheets,
alternate formats, and general meta data.  Example:
  <head>
    <meta charset="utf-8" />  
    <link rel="stylesheet" href="/path/to/styles.css" />
    <link rel="alternate" type="application/atom+xml" href="/feed.xml" />
  </head>

Many of the mandatory HTML4 attributes were dropped in favor of defaults.  IE,
you no longer have to specify the type="text/css" for stylesheets.

## New Semantic Elements
From the specification: 
@link(http://www.whatwg.org/specs/web-apps/current-work/multipage/sections.html)

New elements include:
+-----------+-----------------------------------------------------------------+
| <section> | Represents a generic section of a document, provides thematic   |
|           | grouping, typically with a header.                              |
+-----------+-----------------------------------------------------------------+
| <nav>     | Represents a section that links to other pages or parts.        |
|           | Only major navigations are appropriate for <nav>, for example a |
|           | footer with many links is not appropriate.                      |
+-----------+-----------------------------------------------------------------+
| <article> | A self-contained composition in a document, which can be        |
|           | independently distributed.  Eg: newspaper article, blog entry,  |
|           | user comment, or interactive widget                             |
+-----------+-----------------------------------------------------------------+
| <aside>   | Sections which are only tagnentially related to the main        |
|           | content of the page.  Eg: sidebars, ads, or featured quotes.    |
+-----------+-----------------------------------------------------------------+
| <hgroup>  | The heading of a section which groups h1-h6 elements when       |
|           | headings have multiple levels.  Eg: subheading or taglines.     |
+-----------+-----------------------------------------------------------------+
| <header>  | Introductory or navigational aids.  Usually contains h1-h6 and  |
|           | hgroup elements.  May also contain table of contents, search    |
|           | form, or relevant logos.                                        |
+-----------+-----------------------------------------------------------------+
| <footer>  | Typically contains information about its ancestor such as the   |
|           | author, links to related documents, or copyright.               |
+-----------+-----------------------------------------------------------------+
| <time>    | Either a time on a 24-hour clock or precise date.               |
+-----------+-----------------------------------------------------------------+
| <mark>    | Run of text in one document highlighted for reference.          |
+-----------+-----------------------------------------------------------------+

Not all browsers support these elements yet.  Two important questions to ask
when a browser finds an {{ unknown element }}:
- How should this element be styled?
- What should the element's DOM look like?

For non-IE browsers, you can style unknown elements:
  article { border: 1px solid red; } /* Won't be applied in IE < 9 */

Unfortunately, if IE doesn't recognize the element name, it will insert the
element into the DOM as an empty node with no children.  Any actual children
will become siblings.

To solve both problems in IE, just create a dummy element of the same type
before you use it in the page:
  <head>
    <!-- Now articles will be recognized! -->
    <script>document.createElement("article");</script>
  </head>

Here is the HTML5 enabling script for IE by Remy Sharp:
  @link(http://html5shiv.googlecode.com/svn/trunk/html5.js)
  <!--[if lt IE 9]> <script>
    var e = ("abbr,article,aside,audio,canvas,datalist,details," + 
             "figure,footer,header,hgroup,mark,menu,meter,nav,output," + 
             "progress,section,time,video").split(',');
    for (var i = 0; i < e.length; i++) {
      document.createElement(e[i]);
    } 
  </script> <![endif]-->

# Canvas
The {{ <canvas> }} element is a "resolution-dependent bitmap canvas which
can be used for rendering graphs, game graphics, or other visual images
on the fly."  Example:
  <canvas id="acanvas" width="300" height="225"></canvas>
  <script>
    var a_canvas = document.getElementById("acanvas");
    a_canvas.getContext("2d");  /* only supported context right now */
    a_canvas.fillRect(50, 25, 150, 100)
  </script>

Canvas support for IE7+ is available via the {{ excanvas library }}.  To detect
support for canvas:
  !!document.createElement("canvas").getContext;

A sample of the API for drawing shapes:
- fillStyle property, which can be a CSS color or pattern or gradient
- fillRect(x, y, width, height) draws a recntangle
- strokeStyle property is just like fillStyle
- strokeRect(x, y, width, height) draws a rectangle w/ current strokeStyle
- clearRect(x, y, width, height) clears the pixels in specificed rectangle

To reset the canvas, just set its width:
  a_canvas.width = a_canvas.widht;   // works even if it's the same width

Lines are drawn using {{ paths }}:
- moveTo(x, y) moves your pencil to this coordinate
- lineTo(x, y) draws a line to specified ending point
- stroke() will actually do the drawing (like finalizing in ink)
  this also uses the current strokeStyle of the context

Example:
  context.beginPath();
  context.moveTo(0, 40);
  context.lineTo(240, 40);
  context.strokeStyle = "#000";
  context.stroke();

Text may also be drawn onto the canvas:
- font property is similar to any CSS font rule, including: font style, variant,
  weight, size, line-height, and font family.
- textAlign property controls the alignment.  Possible values are: start, end,
  left, right, and center.
- textBaseline controls where the text is drawn relative to the starting point.
  Values are: top, hanging, middle, alphabetic, ideographic, and bottom.

Example:
  context.font = "bold 12px sans-serif";
  context.fillText("Lorem Ipsum", 248, 43);

Gradients can be created via:
- createLinearGradient(x0, y0, x1, y1)
- createRadialGradient(x0, y0, r0, x1, y1, r1)

Example:
  var gradient = context.createLinearGradient(0, 0, 300, 0);
  gradient.addColorStop(0, "black");
  gradient.addColorStop(1, "white");
  context.fillStyle = gradient;
  context.fillRect(0, 0, 300, 225);

To draw an image onto the canvas:
- drawImage(image, dx, dy) where dx/dy make up the upper-left corner
- drawImage(image, dx, dy, dw, dh) scales it to dw/dh
- drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) to clip and scale

Example:
  context.drawImage(document.getElementById("id-of-img-element"), 0, 0);

# Video
HTML5 defines a standard way to embed video into a web page using the 
<video> element.

## Feature Detection
To detect whether the browser supports HTML5 video or not:
  !!document.createElement("video").canPlayType;

To detect whether or not it can play a certain format:
  var v = document.createElement("video");
  v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');

This will return one of 3 values:
- "probably" if the browser is confident it can play it
- "maybe" if the browser thinks it can play it
- "" if the browser is certain it cannot play it

## Video Containers
"AVI" and "MP4" are just container formats like how a ZIP file can contain
any sort of file within it.  Container formats define how to store things in
them and what kind of data is stored.  Some of hte most popular formats are:
- MPEG-4 (mp4, m4v)
- Flash Video (flv)
- Ogg (ogv)

## Video Codecs
When you watch a video, your player is:
- interpreting the container format to find out which video/audo tracks
  are available and how they are stored
- decoding the video stream to display images onto the screen
- decoding the audio stream to send sound to speakers

{{ Codec }} is a combination of "coder" and "decoder".  It's the algorithm
used to encode video streams.  The video player decodes a video stream to
display a series of images, aka {{ frames }} to the screen.

Some popular video codecs are:
- H.264 (aka MPEG-4 part 10)
- Theora
- VP8 

Some popular audio codecs are:
- MPEG-1 Audo Layer (aka mp3)
- Advanced Audio Coding (AAC)
- Vorbis

For cross browser reasons, you'll have to encode your video in more than one
format and probably provide a fallback mechanism for IE < 9.
- FF >3.5 and Opera >10.5 supports Theora video and Vorbis audio 
  in an Ogg container
- Chrome >3.0 supports supports Theora/Vorbis in an Ogg container.  Also
  supports H.264 video and AAC audio in an MP4 container.
- Safari support anything QuickTime supports.  Out of the box this does
  not include Theora/Vorbis in Ogg.  It does support H.264 and AAC in an
  MP4 container.
- Mobile devices like iPhone and Android phones support H.264/AAC in MP4.
- Flash supports H.264/AAC in an MP4 container also.
- IE9 will support H.264 and AAC in MP4.
- IE <9 have no support for HTML5 video, you'll need to fallback to flash.

To encode ogg video, use the {{ Firefogg }} Firefox plugin.  To encode H.264,
use the open source {{ HandBrake }} application.

## The Markup
The markup is similar to the <img> element:
  <video src="videofile.mp4" width="320" height="240"></video>

Your browser will center the video inside the box.  It won't be scaled out of
proportion.

The <video> element does not expose any player controls.  You can do that
yourself using its API: play(), pause(), and currentTime property.  There's
also volume/muted properties.  If you don't want to build your own UI, you
can use the browser's default with the {{ controls }} property:
  <video src="videofile.mp4" width="320" height="240" controls></vide>

There's also the {{ preload }} property which will begin downloading the
video file and the {{ autoplay }} property.

A <video> element may have <source> children.  This is useful to have more
than one encoding to support multiple browsers:
  <video width="320" height="240" controls> 
    <source src="pr6.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'> 
    <source src="pr6.webm" type='video/webm; codecs="vp8, vorbis"'> 
    <source src="pr6.ogv" type='video/ogg; codecs="theora, vorbis"'>
  </video>

The {{ type }} attribute is important so the browser won't have to download an
entire video file just to check to see if it can play it.

Important: VIDEO FILES MUST BE SERVED WITH THE PROPER MIME TYPE!

For IE, you'll need to fallback using Flash.  A recommended library to use is
{{ FlowPlayer }}.

# Geolocation
Geolocation lets you figure out where in the world the user is.  Privacy is a
strong concern and user agents must not send location information to websites
without the express permission of the user.

## Feature Detection
If your browser supports geolocation, there will be a geolocation property on
the global navigator object:
  !!navigator.geolocation

## Usage
The first time you ask for a user's location, the end user will decide whether
or not to disclose it.  The end user gets to know which website wants to know
the location, can choose to share or not share it, and can tell the browser
to remember the choice.

Example usage:
  navigator.geolocation.getCurrentPosition(function(position) {
    var latitute = position.coords.latitude;
    var longitude = position.coords.longitude;
    var timestamp = position.timestamp;
  });

Properties are:
- coords.latitutde (double, decimal degrees)
- coords.longitude (double, decimal degrees)
- coords.altitude (double or null)
- coords.accuracy (doubles in meters)
- coords.altitudeAccuracy (double in meters)
- coords.heading (degrees clockwise from true north, double or null)
- coords.speed (double or null, meters/second)
- timestamp (DOMTimeStamp, like Date() object)

You may also include error handling:
  navigator.geolocation.getCurrentPosition(fn_callback, error_callback);
  function error_callback(code, message) {
    /* code is a short, enumerated value */
    /* message is a string, not intended for end users */
  }

Possible error codes are:
- 1 = PERMISSION_DENIED
- 2 = POSITION_UNAVAILABLE
- 3 = TIMEOUT
- 4 = UNKNOWN_ERROR

getCurrentPosition has a third optional parameter, a PositionOptions object with
three possible properties:
- enableHighAccuracy (boolean)
- timeout (long in milliseconds)
- maximumAge (long in milliseconds)

## IE Support
IE does not support the geolocation API, but you can fallback onto the Gears
library.  {{ geo.js }} is an abstraction above the standards HTML5 geolocation
and Gears.

# Local Storage
# Offline Web Apps
# Forms
# Microdata

